 # Day 5 - Pandas 入门

 本节结合一个简单的价格数据示例，理解 Pandas 中几个常用方法的作用：

 ```python
 import pandas as pd

 # 创建简单的价格数据
 df = pd.DataFrame({
     'date': pd.date_range('2024-01-01', periods=10),
     'price': [100, 102, 101, 105, 103, 107, 106, 108, 110, 109]
 })

 # 计算收益率
 df['return'] = df['price'].pct_change()

 # 计算移动平均
 df['ma5'] = df['price'].rolling(window=5).mean()
 ```

 ---

 ## 1. Pandas 中的 Series 和 DataFrame

 - **Series**：一列数据，带索引，类似「带行号的一维数组」。
 - **DataFrame**：由多列 Series 组成的表格，类似数据库中的一张表或 Excel 表。

 在上面的代码中：

 - `df` 是一个 `DataFrame`
 - `df['price']`、`df['return']`、`df['ma5']` 都是 `Series`

 ---

 ## 2. `pd.DataFrame({...})`：创建表格数据

 ```python
 df = pd.DataFrame({
     'date': pd.date_range('2024-01-01', periods=10),
     'price': [100, 102, 101, 105, 103, 107, 106, 108, 110, 109]
 })
 ```

 - 数学/数据思想：
   - 用「列名 → 一列数据」的方式，定义一张表的每一列。
   - 各列长度要一致，这样才能按行对齐。
 - 直观理解：
   - 可以把字典的 key 当成 Excel 的「列标题」，value 当成这一列的所有单元格。

 这里创建了两列：

 - `date`：日期列
 - `price`：每天的价格列

 ---

 ## 3. `pd.date_range()`：生成一段日期序列

 ```python
 pd.date_range('2024-01-01', periods=10)
 ```

 - 数学/数据思想：
   - 生成一段「等间隔」的时间序列，这里步长是 1 天，总共 10 个点。
 - 直观理解：
   - 从 2024-01-01 开始，自动帮你往后数 10 天，得到一列日期。

 常见参数：

 - `start`：开始日期，如 `'2024-01-01'`
 - `periods`：要生成多少个日期
 - 或者用 `end`：结束日期 + `freq`：步长（如 `'D'` 表示按天）

 ---

 ## 4. 列操作：添加 / 删除 / 计算

 在例子中有：

 ```python
 df['return'] = df['price'].pct_change()
 df['ma5'] = df['price'].rolling(window=5).mean()
 ```

 - **添加列**：
   - 直接给一个新列名赋值：`df['new_col'] = ...`
 - **基于旧列计算新列**：
   - `df['return']`、`df['ma5']` 就是基于 `price` 计算出来的新列。
 - **删除列**（这里只做说明）：
   - `df.drop(columns=['col_name'], inplace=True)`
   - 或 `del df['col_name']`

 直观理解：

 - 把一列当做 Excel 里的某一列，在上面做加减乘除、新建列、删列等操作。

 ---

 ## 5. `loc[]` 和 `iloc[]`：选行选列

 虽然示例代码里没用到，但这是 Day 5 要掌握的核心方法。

 - 数学/数据思想：
   - 本质上是从一个矩阵/表格里，按「行索引」和「列名/位置」取出子矩阵。
 - 直观理解：
   - `loc`：按「标签」取（行号名字、列名）
   - `iloc`：按「位置」取（第几行、第几列，从 0 开始）

 示例：

 ```python
 # 前 3 行，所有列（位置）
 df.iloc[0:3]

 # 指定行标签（比如日期是索引时）和列名
 df.loc['2024-01-03':'2024-01-05', ['price', 'return']]
 ```

 可以先理解为：

 - `iloc[row_slice, col_slice]`：纯数字下标切片
 - `loc[row_labels, col_labels]`：用「名字」来切片

 ---

 ## 6. `pct_change()`：计算收益率

 ```python
 df['return'] = df['price'].pct_change()
 ```

 - 数学思想：
   - 收益率 = (今日价格 - 昨日价格) / 昨日价格
   - 也就是相对变化百分比。
 - 直观理解：
   - 昨天 100，今天 105 → `(105 - 100) / 100 = 0.05`，即 5% 收益。

 `pct_change()` 会：

 - 默认和上一行相比，计算「当前值相对上一行的变化比例」。
 - 第一行因为没有前一天，会是 `NaN`（空值）。

 你可以把 `df['return']` 理解为「每天相对于前一天涨跌了多少百分比」。

 ---

 ## 7. `rolling(window=5).mean()`：5 日移动平均

 ```python
 df['ma5'] = df['price'].rolling(window=5).mean()
 ```

 - 数学思想：
   - 对序列取「滑动窗口」：
     - 每次拿最近 `window` 个值，求一个平均。
     - 窗口向前滑动，就得到一条更平滑的曲线。
 - 直观理解：
   - `ma5` = 最近 5 天的平均价格。它会把短期的剧烈波动「抹平」一些，更容易看趋势。

 例子（只看价格）：

 - 第 1～4 天，因为不足 5 天，`ma5` 一般为 `NaN`。
 - 第 5 天的 `ma5` = 第 1～5 天价格的平均；
 - 第 6 天的 `ma5` = 第 2～6 天价格的平均；以此类推。

 ---

 ## 8. 小结

 本节你需要掌握：

 - **数据结构**：`Series`、`DataFrame`
 - **创建数据**：`pd.DataFrame`、`pd.date_range`
 - **列操作**：新增列、基于旧列计算新列
 - **索引方式**：`loc[]`（按标签）、`iloc[]`（按位置）
 - **常用时间序列指标**：收益率 `pct_change()`、移动平均 `rolling().mean()`

 这些是后面做量化回测、构建策略时，几乎每个项目都会用到的基础积木。

