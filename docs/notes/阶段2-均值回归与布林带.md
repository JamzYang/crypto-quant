## 阶段 2 第 2 块：均值回归原型 + 布林带策略学习笔记

### 0. 本块的学习目标（结果导向）

读完并实践完这一块后，我应该能够独立做到：

- **对比解释**：用自己的话说明均值回归和趋势跟随在世界观上的根本区别。
- **讲清楚**：布林带（三条轨道）的构成、直觉含义，以及它如何衡量「价格偏离程度」。
- **写出** 一套基于布林带的简单均值回归交易规则（只做多版本），并补齐建仓/平仓/空仓等细节。
- **翻译** 这套规则为伪代码，并在实现时刻意规避未来函数和数据泄露。
- **实现与回测**：基于 pandas 写出单标的布林带均值回归策略和回测脚本，输出资金曲线和基础指标。
- **评估与复盘**：能从回测结果中看出策略在明显趋势段 vs 震荡段的表现差异，并总结适合/不适合它的行情。


### 1. 本学习块在整体计划中的位置

- **与第 1 块的关系**：
  - 第 1 块用双均线代表「趋势跟随」世界观：看到价格走出方向就追着走。
  - 第 2 块用布林带代表「均值回归」世界观：看到价格偏离太远就赌它会往中间回。
  - 两者刚好是「追涨杀跌」和「逢低买入」两种截然不同的思维方式。

- **本块主要解决什么问题？**
  - 理解「价格有时会围绕某个中枢上下摆动」这一类场景，并思考如何用规则去吃「回到中枢」这段路。
  - 学会用布林带这个非常常见的技术指标，来定量描述「偏离程度」，而不是拍脑袋觉得「价格好像涨多了/跌多了」。

- **它为后续哪些内容打基础？**
  - 后续波动率调仓模块中会用到滚动标准差的直觉，而布林带本身就深度依赖「滚动标准差」。
  - 综合复盘阶段需要对比「趋势策略 vs 均值回归策略」在不同市场环境下的表现，本块提供了均值回归这条线的第一个原型。


### 2. 本块的核心问题 & 直觉图景

学习计划里的两个核心问题：

- 均值回归和趋势跟随的「世界观」有什么根本差别？
- 如何让策略「在震荡市吃肉，在趋势市少被砍头」？

我的直觉图景：

- **趋势跟随**：
  - 假设「大趋势一旦形成，会持续一段时间」，核心动作是「顺势而为」。
  - 看上去像是在追逐「一条长坡厚雪」。

- **均值回归**：
  - 假设「价格大部分时间会在一个中枢附近上下波动，极端偏离之后有回到中枢的倾向」，核心动作是「逢低买入、逢高卖出」。
  - 更像是在一个区间里做「高抛低吸」。

- **布林带的直觉图景**：
  - 中轨 = 一段时间内的平均价，代表「价格大致的中枢」。
  - 上、下轨 = 中轨 ± k × 标准差，代表「正常波动范围」的边界。
  - 当价格跌破下轨，就像一个弹簧被拉得太长，有机会向中轨方向弹回；当价格冲过上轨，也可能向下回落。


### 3. 关键概念与术语说明

#### 3.1 均值回归（Mean Reversion）

- **直觉解释**：
  - 「偏离太远迟早要回来」。
  - 很多资产的价格或收益率，在长期内会围绕某个均值上下波动，极端偏离往往是暂时的。

- **稍正式一点的描述**：
  - 若某个时间序列的偏离程度（相对某个均值）具有「向均值回归的倾向」，则可以围绕这个均值构建「偏离过大时做反向仓位」的策略。

- **例子**：
  - 股票价格在一个箱体内震荡：每次跌到下沿附近就有资金承接，每次涨到上沿附近就有人获利了结，价格长期围绕箱体中枢附近波动。

#### 3.2 布林带（Bollinger Bands）

- **构成**：
  - 中轨：N 日移动平均（如 20 日均线）。
  - 上轨：中轨 + k × N 日滚动标准差。
  - 下轨：中轨 − k × N 日滚动标准差。

- **直觉含义**：
  - 中轨代表「近期合理价格区域的中枢」。
  - 上、下轨代表「大部分价格应该落在其中的区间」。
  - 当价格靠近甚至突破上下轨时，可以理解为「在近期波动背景下比较极端的位置」。

#### 3.3 滚动标准差（Rolling Std）

- **直觉解释**：
  - 「最近这段时间，价格抖动得厉不厉害」。

- **在布林带里的角色**：
  - 标准差越大，说明波动越剧烈，布林带就会变宽；
  - 标准差越小，说明价格比较平稳，布林带就会收窄。


### 4. 策略画像：均值回归版布林带策略

#### 4.1 赚谁的钱？

- 赚「在区间里追涨杀跌的人」的钱：
  - 他们往往在价格接近上轨时冲进去，在价格回落到中轨甚至下轨时斩仓离场。
  - 均值回归策略则在价格偏离到下轨附近时买入，等价格回到中轨附近卖出，吃的是「从极端到中间」这段路。

#### 4.2 适合什么行情 / 在什么行情容易连续亏损？

- **适合的行情**：
  - 典型的箱体震荡区间：价格在一个大致稳定的区间内上下波动，没有明确的单边趋势。
  - 在这种环境下，「逢低买入、逢高卖出」的逻辑更有发挥空间。

- **容易连续亏损的行情**：
  - 大级别单边趋势：
    - 比如一波持续的上涨：价格不断沿着上轨甚至站在上轨之上缓慢爬升；
    - 或一波持续的下跌：价格沿着下轨一路向下滑。
  - 在这样的行情里，均值回归策略会不断在下跌途中「以为跌多了」而接盘，被一路拖着下去。

#### 4.3 主要风险与大坑

- 「越跌越买」带来的风险：
  - 如果不控制每次买入的仓位比例，纯粹按「跌多了就满仓买」的逻辑，很容易在单边下跌中快速深套。

- 对参数高度敏感：
  - 不同的窗口长度（N）和标准差倍数（k）会显著改变上下轨的位置，策略表现也会完全不同。

- 忽略波动率 regime：
  - 在高波动期，布林带非常宽，价格穿越上下轨的意义和在低波动期可能完全不同。


### 5. 中文规则 → 完整描述（只做多版本）

以学习计划中的策略示例为基础，我先给出一个简化版的「只做多、只做多头均值回归」规则：

1. **标的与周期**：
   - 标的：BTC/USDT 现货（或等价现货价格序列）。
   - 周期：日线 K 线。

2. **布林带参数**：
   - 窗口长度 N：20（日）。
   - 标准差倍数 k：2.0。

3. **指标定义**：
   - 中轨 `BB_mid(t)`：过去 N 天收盘价的简单平均。
   - 滚动标准差 `BB_std(t)`：过去 N 天收盘价的标准差（这里用价格而不是收益率）。
   - 上轨 `BB_upper(t) = BB_mid(t) + k × BB_std(t)`。
   - 下轨 `BB_lower(t) = BB_mid(t) − k × BB_std(t)`。

4. **当期信号定义**（只做多）：
   - 若收盘价 `close(t) < BB_lower(t)`：
     - 认为价格严重低估，记当期信号 `signal_t = 1`（看多，准备建多头仓位）。
   - 若收盘价 `close(t) >= BB_mid(t)`：
     - 认为价格已经回到合理区间甚至偏贵，记 `signal_t = 0`（不再持有多头）。
   - 否则（介于下轨和中轨之间）：
     - 保持前一日的信号不变，即沿用 `signal_{t-1}`。

5. **实际持仓（避免未来函数）**：
   - 第 `t` 天收盘后，根据当期信号 `signal_t` 决定第 `t+1` 天的持仓：
     - `position_{t+1} = signal_t`。
   - 初始设定 `position_1 = 0`（一开始空仓）。

6. **交易生命周期**：
   - **开仓（从 0 → 1）**：
     - 若 `position_t = 0` 且 `position_{t+1} = 1`，则在第 `t+1` 天开盘或接近开盘的价位买入，满仓做多。
   - **持仓（保持 1）**：
     - 若 `position_t = 1` 且 `position_{t+1} = 1`，继续持有，不做任何交易。
   - **平仓（从 1 → 0）**：
     - 若 `position_t = 1` 且 `position_{t+1} = 0`，则在第 `t+1` 天全部卖出，回到空仓。

7. **仓位与成本假设（简化版）**：
   - 每次建仓都是用全部可用资金买入标的，即「满仓多头」。
   - 手续费和滑点通过一个统一的 `fee_rate` 近似处理：
     - 每当持仓发生变化（0→1 或 1→0），视为发生了一次换手；
     - 当天的策略收益中额外扣减 `fee_rate × |position_t − position_{t-1}|` 作为成本。


### 6. 从中文描述到伪代码

```text
输入：
  - 时间序列 t = 1...T
  - 每日收盘价 close[t]
参数：
  - N = 20  # 滚动窗口长度
  - k = 2.0 # 标准差倍数

步骤：
1. 计算布林带：
   对每个 t：
     BB_mid[t] = 过去 N 日 close 的均值
     BB_std[t] = 过去 N 日 close 的标准差
     BB_upper[t] = BB_mid[t] + k * BB_std[t]
     BB_lower[t] = BB_mid[t] - k * BB_std[t]

2. 构造原始信号 signal_raw[t]：
   if close[t] < BB_lower[t]:
       signal_raw[t] = 1
   elif close[t] >= BB_mid[t]:
       signal_raw[t] = 0
   else:
       signal_raw[t] = 空

3. 平滑信号 signal[t]：
   signal[1] = 0
   对 t 从 2 到 T：
       if signal_raw[t] 是 0 或 1：
           signal[t] = signal_raw[t]
       else:
           signal[t] = signal[t-1]

4. 实际持仓 position[t]：
   position[1] = 0
   对 t 从 1 到 T-1：
       position[t+1] = signal[t]

5. 收益与资金曲线：
   先计算标的日简单收益：
       ret[t] = close[t] / close[t-1] - 1

   再计算策略收益（忽略手续费版本）：
       strategy_ret[t] = position[t-1] * ret[t]

   资金曲线：
       equity[0] = 1.0
       对 t 从 1 到 T：
           equity[t] = equity[t-1] * (1 + strategy_ret[t])

输出：
  - BB_mid, BB_upper, BB_lower
  - signal, position
  - strategy_ret, equity
```

在 pandas 中，对应的实现思路也很直接：

- 布林带 = `rolling().mean()` + `rolling().std()`；
- 原始信号 = `where()` / 布尔索引；
- 平滑信号 = `ffill().fillna(0)`；
- 持仓 = `signal.shift(1)`；
- 策略收益 = `position * ret`；
- 资金曲线 = `(1 + strategy_ret).cumprod()`。


### 7. 伪代码 → 回测代码（src/stage2）

在当前仓库中，我为第 2 块新增了以下代码文件：

1. **策略层：`src/stage2/strategies/bollinger_mean_reversion.py`**

   - `BollingerConfig`：
     - 使用 dataclass 描述布林带参数：`window`（窗口长度）、`num_std`（标准差倍数）、`price_col`（价格列名）。
     - `validate()` 方法负责检查参数合法性（窗口为正、标准差倍数为正）。

   - `BollingerMeanReversionStrategy`：
     - `generate_signals(df)` 方法：
       - 计算布林带：`bb_mid`、`bb_std`、`bb_upper`、`bb_lower`；
       - 构造原始信号 `signal_raw`：价格低于下轨记为 1，高于中轨记为 0，其余为 NaN；
       - 用 `ffill().fillna(0)` 得到平滑后的 `signal`；
       - `position = signal.shift(1)`，避免未来函数；
       - 标记 `enter_long`（0→1）和 `exit_long`（1→0）事件，方便之后画图和复盘。

2. **回测脚本：`src/stage2/backtests/bt_bollinger_single_symbol.py`**

   - `run_bollinger_backtest(...)`：
     - 使用 `load_ohlcv_csv` + `add_return_columns` 读入 BTC/USDT 日线并计算日收益 `ret`；
     - 调用 `BollingerMeanReversionStrategy.generate_signals()` 得到布林带和持仓；
     - 构造简单持有基准：`bh_ret`、`bh_equity`；
     - 构造策略收益：
       - `strategy_ret_gross = position * ret`；
       - 用 `position.diff().abs()` 近似换手率，扣减手续费得到 `strategy_ret`；
     - 计算资金曲线：`strategy_equity` 与 `bh_equity`；
     - 通过 `compute_performance_stats` 计算总收益、年化收益、年化波动率、Sharpe、最大回撤等指标；
     - 可选 `plot=True` 时画出「价格 + 布林带 + 开平仓点」以及「资金曲线对比」。

   - `print_bollinger_stats(stats)`：
     - 以中文标签格式化打印布林带策略与简单持有的绩效指标。

   - `main()`：
     - 默认使用项目根目录下 `dist/btc_data.csv` 作为数据源，跑一遍布林带回测并打印结果预览。

整体结构与第 1 块的双均线回测保持一致，方便后续进行对比实验和扩展。


### 8. 初步评估与对比思路

在实际运行布林带回测时，可以重点关注以下几个维度：

- 与简单持有相比：
  - 收益是否更高或更低？
  - 最大回撤是否显著下降？
  - Sharpe 比率是否有改善？

- 与双均线趋势策略相比：
  - 在明显震荡区间：布林带策略的表现是否优于趋势策略？
  - 在明显趋势区间：布林带策略是否因为「过早认为价格偏离太多」而频繁逆势开仓，导致被拖累？

这里可以选择几个典型时间段：

- 明显单边上升段；
- 明显单边下跌段；
- 明确的箱体震荡段；

分别在这些子区间上回测布林带策略和双均线策略，直接肉眼对比资金曲线和回撤曲线，再结合数字指标做总结。


### 9. 常见坑与自查清单

1. **未来函数 / 数据泄露**：
   - 是否始终使用「今天的信号决定明天的持仓」？
   - 是否在布林带计算中只用到了当日及之前的数据？

2. **参数过度调优**：
   - 是否在同一段历史上反复调 N 和 k，只挑出表现最好的一组？
   - 是否有计划在后续做简单的样本外验证？

3. **高波动期的错误解读**：
   - 在高波动期布林带很宽，价格「穿上下轨」的含义可能与低波动期完全不同；
   - 是否考虑过在高波动期减小仓位，或提高开仓阈值？

4. **仓位与风险控制**：
   - 是否所有开仓都是满仓？如果是，是否评估过在极端行情下的最坏回撤？
   - 是否有简单的止损机制（例如价格跌破下轨后继续暴跌时何时认亏）？


### 10. 小结与下一步

**这一块我已经搞清楚了什么？**

- 均值回归与趋势跟随在世界观上的核心差别：前者赌「回到中枢」，后者赌「顺着方向走」。
- 布林带如何通过「移动平均 + 滚动标准差」来描述价格的正常波动区间，以及如何用上下轨界定「极端位置」。
- 如何从一套基于布林带的中文规则，推导出伪代码，再落地为 pandas 回测代码（`BollingerMeanReversionStrategy` + `bt_bollinger_single_symbol.py`）。

**还有哪些地方暂时没想透？**

- 如何根据不同标的和不同市场环境，有系统地选择 N 和 k，而不是只凭经验或盯着回测曲线调参数。
- 如何在布林带策略中更好地结合「波动率 regime」（高波动 vs 低波动），避免在高波动趋势市中不断「接飞刀」。

**下一步自然的学习方向：**

1. 在现有框架上做一轮简单的参数敏感性测试：
   - 尝试多组 (N, k) 组合，例如 (20, 2)、(20, 3)、(10, 2)、(30, 2)，对比收益、回撤和 Sharpe 的变化。

2. 与第 1 块的趋势策略做系统对比：
   - 在同一个 BTC/USDT 样本区间上，同时回测布林带策略和双均线策略；
   - 选出几个代表性区间（趋势段 vs 震荡段），观察两者表现差异，并记录在阶段性综合报告中。

3. 为第 3 块「波动率调仓策略」做铺垫：
   - 利用布林带中的滚动标准差，初步构造一个简单的「高波动减仓、低波动加仓」示例，为后续在趋势或均值回归策略之上叠加波动率模块做好准备。
