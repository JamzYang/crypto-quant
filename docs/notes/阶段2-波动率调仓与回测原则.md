## 阶段 2 第 3 块：波动率调仓策略 + 回测原则深化学习笔记

### 0. 本块的学习目标（结果导向）

读完并实践完这一块后，我应该能够独立做到：

- **解释** 波动率如何影响仓位大小与账户风险暴露，用直觉而不是公式堆砌。
- **设计** 一套简单的「高波动减仓、低波动加仓」规则，并说清楚为什么这样设计。
- **实现** 一个波动率调仓模块，并把它叠加到已有的趋势策略上，跑通回测。
- **识别与规避** 几个典型的回测大坑：未来函数、数据泄露、过度调参等，并给出自查 checklist。
- **对比分析**：能读懂「原始趋势策略 vs 加了波动率调仓的趋势策略 vs 简单持有」三条资金曲线和指标差异。


### 1. 本学习块在整体计划中的位置

- 前两块已经有了：
  - 趋势跟随（双均线）：决定**方向**和「要不要上场」。
  - 均值回归（布林带）：在震荡中「逢低买入、逢高卖出」。
- 第 3 块开始关注的是：
  - 在**同样的交易信号**下，
  - 如何根据「市场有多剧烈」来决定**上多大仓位**。

换句话说：

- 之前重点是「什么时候做多 / 空仓」。
- 现在要加一层「做多的时候，是 1 倍仓，还是 0.5 倍仓，还是干脆减仓观望」。

这一块同时也是**回测原则的强化练习**：

- 如何在不偷看未来的前提下，使用滚动统计量（如滚动标准差）。
- 如何避免在全样本上「先看完所有数据，再回头设阈值」，从而产生数据泄露。


### 2. 核心问题 & 直觉图景

学习计划提到的核心问题：

- 波动率如何影响仓位大小与风险暴露？
- 如何在回测中避免明显的「未来函数 / 数据泄露」？

我的直觉图景是：

- 当市场很平稳（波动率低）时：
  - 每天价格晃动不大，止损距离可以设得相对紧，
  - 用更大的仓位也不会一下子把账户炸穿。
- 当市场很暴躁（波动率高）时：
  - 每天价格像过山车，
  - 同样的仓位在这种环境下，账户净值会来回拉扯得很厉害。

类比：

- 在平坦的公路上（低波动），你可以开快一点（高仓位）。
- 在山路冰雪路（高波动），即使你方向盘没变，也应该自动把车速降下来（减仓），否则一脚就翻车。


### 3. 关键概念与术语说明

#### 3.1 波动率（这里的工作定义）

- 严格的金融定义可以很复杂，这里用一个**工作定义**：
  - 用「最近 N 天收益率的标准差」来刻画「近期是否剧烈波动」。
- 直觉：
  - 标准差越大，说明收益在上下两边抖得越厉害，风险越难掌控。

#### 3.2 波动率 regime（低/中/高波动区间）

- 为了把不同波动环境下的策略表现看清楚，我们通常会把市场粗分为：
  - 低波动：价格比较稳，收益曲线平滑；
  - 中等波动：起伏适中；
  - 高波动：大阴大阳频繁，甚至连续跳空。

- 本块中采用的一个简化做法：
  - 用固定阈值划分：
    - `vol <= low_threshold` 视为「低波动」；
    - `vol >= high_threshold` 视为「高波动」；
    - 其他视为「中等波动」。
  - 这样做的好处是避免在全样本上先看完所有数据再定分位数（那样容易产生数据泄露）。

#### 3.3 未来函数与数据泄露

- **未来函数**：
  - 在决策时偷看了未来的信息，比如：
    - 用第 t+1 天的收盘价来决定第 t+1 天的持仓；
    - 用未来一段时间的最高/最低价来设今天的止损位等。

- **数据泄露**：
  - 在回测框架之外，用了样本外或未来数据来「先调好参数再回测」，比如：
    - 在整个 2018–2024 全样本上先算完波动率的分布，再用这个分布的分位数来定义 2018 年的波动 regime。

在这一块里，最容易踩的坑就是：

- 用全样本的波动率分布来设阈值，却假装在做「在线决策」。


### 4. 规则设计：高波动减仓、低波动加仓

这一块我选用「在双均线趋势策略上叠加波动率调仓」作为示例：

- 底层信号策略：
  - 使用第 1 块中已经实现的 `MATrendStrategy`（20/60 双均线趋势）。
  - 它给出的 `position` 表示「是否做多」：0 = 空仓，1 = 满仓做多。

- 在此基础上，加一层「波动率调仓」：

1. **波动率度量**：
   - 使用日收益率 `ret(t)` 的滚动标准差：
     - `vol(t) = std( ret_{t - W + 1}, ..., ret_t )`。
   - W：波动率窗口长度，例如 30 天。

2. **regime 划分**：
   - 选定两个固定阈值 `low_threshold`、`high_threshold`：
     - 若 `vol(t) <= low_threshold` → 「低波动」；
     - 若 `vol(t) >= high_threshold` → 「高波动」；
     - 否则 → 「中等波动」。

3. **仓位规则**（示例模板）：
   - 低波动（`vol` 低）：
     - 底层策略想做多时，上较高仓位，例如 100% 仓位；
   - 中等波动：
     - 上中等仓位，例如 60%；
   - 高波动：
     - 尽量轻仓，例如 30%，甚至完全观望（0）。

4. **与趋势信号的结合**：
   - 底层趋势信号给出的是「方向」：做多还是空仓；
   - 波动率模块给出的是「仓位倍率」：1.0 / 0.6 / 0.3；
   - 最终仓位 = 趋势仓位 × 仓位倍率。


### 5. 中文规则 → 伪代码描述

结合双均线趋势策略和波动率调仓，规则可以描述为：

```text
输入：
  - 收盘价序列 close[t]
  - 日收益率序列 ret[t]
参数：
  - 短期均线窗口 short_window = 20
  - 长期均线窗口 long_window = 60
  - 波动率窗口 vol_window = 30
  - 低波动阈值 low_th
  - 高波动阈值 high_th
  - 仓位倍率：
      pos_low = 1.0
      pos_med = 0.6
      pos_high = 0.3

步骤：
1. 生成趋势信号（与第 1 块相同）：
   - 计算 ma_short[t], ma_long[t]
   - 当 ma_short[t] > ma_long[t]: signal_trend[t] = 1，否则为 0
   - 底层趋势持仓（避免未来函数）：
       position_trend[1] = 0
       对 t=1..T-1:
           position_trend[t+1] = signal_trend[t]

2. 计算波动率：
   对每个 t：
     vol[t] = past vol_window 天 ret 的标准差

3. 划分波动 regime 并给出仓位倍率：
   对每个 t：
     if vol[t] <= low_th:
         regime[t] = "low"
         mult[t] = pos_low
     elif vol[t] >= high_th:
         regime[t] = "high"
         mult[t] = pos_high
     else:
         regime[t] = "medium"
         mult[t] = pos_med

4. 生成波动率调整后的持仓：
   对每个 t：
     position_vol[t] = position_trend[t] * mult[t]

5. 收益与资金曲线：
   - 原始趋势策略：
       trend_ret[t] = position_trend[t-1] * ret[t]
   - 叠加波动率调仓的策略：
       trend_vol_ret[t] = position_vol[t-1] * ret[t]
   - 简单持有：
       bh_ret[t] = ret[t]

   - 各自资金曲线按 (1 + 日收益) 累乘得到。
```

在实现时，关键是「所有决策都只用当前与历史数据」：

- 趋势信号：第 t 天的趋势信号用 t 日的收盘价/均线；
- 波动率：第 t 天的 vol 只用到 t 及之前的收益；
- 第 t+1 天的仓位基于第 t 天的趋势信号和波动率 regime 决定。


### 6. 伪代码 → 回测代码映射（src/stage2）

在当前仓库中，我为第 3 块新增了：

1. **波动率调仓模块：`src/stage2/strategies/volatility_adjustment.py`**

   - `VolatilityAdjustmentConfig`：
     - 参数包括：
       - `window`（波动率滚动窗口天数，默认 30）；
       - `low_threshold` / `high_threshold`（低/高波动阈值）；
       - `ret_col`（收益率列名，默认 `ret`）；
       - `base_position_col`（基础仓位列名，默认 `position`）；
       - `position_low` / `position_medium` / `position_high`（对应三种 regime 下的仓位系数）。

   - `VolatilityAdjuster`：
     - `adjust_positions(df)`：
       - 计算 `vol` 列：基于 `ret_col` 的滚动标准差；
       - 生成 `vol_regime` 列："low" / "medium" / "high"；
       - 生成 `position_multiplier` 列：仓位系数；
       - 生成 `position_vol` 列：基础仓位 × 仓位系数。

2. **叠加波动率调仓的趋势回测脚本：`src/stage2/backtests/bt_trend_with_vol_adjust.py`**

   - `run_trend_with_vol_adjust_backtest(...)`：
     - 读取 `dist/btc_data.csv`，计算日收益率 `ret`；
     - 使用 `MATrendStrategy` 生成原始趋势持仓 `position_trend`；
     - 使用 `VolatilityAdjuster` 生成 `position_vol`（趋势 + 波动率调仓仓位）；
     - 分别计算：
       - 简单持有收益/资金曲线；
       - 原始趋势策略收益/资金曲线；
       - 叠加波动率调仓后的趋势策略收益/资金曲线；
     - 使用 `compute_performance_stats` 计算三条曲线的基础指标；
     - 可选画图，对比三条资金曲线。

   - `print_trend_with_vol_stats(stats)`：
     - 以中文形式打印三条曲线的总收益、年化收益、年化波动率、Sharpe、最大回撤。

   - `main()`：
     - 默认直接从 `dist/btc_data.csv` 读取数据，跑一遍回测并打印结果预览。


### 7. 如何运行第 3 块的回测

在项目根目录下，可以直接运行：

```bash
python3 -m src.stage2.backtests.bt_trend_with_vol_adjust
```

默认参数：

- 趋势策略：短 20、长 60；
- 波动率窗口：30 天；
- 波动阈值：`low_threshold=0.01`，`high_threshold=0.03`；
- 仓位倍率：低波动 1.0，中等 0.6，高波动 0.3；
- 手续费：`fee_rate=0.001`；
- 年化天数：365。

输出内容包括：

- 三套指标：`buy_and_hold` / `trend` / `trend_vol_adjusted`；
- 预览尾部 5 行的价格、均线、波动率、regime、仓位和资金曲线。

在此基础上，你可以尝试：

- 调整 `vol_window` 观察不同窗口对波动 regime 和调仓效果的影响；
- 调整仓位倍率（三档仓位）评估「激进/保守」的风险收益变化。


### 8. 回测原则自查清单（本块重点）

1. **是否存在未来函数？**
   - 趋势信号：
     - 是否使用 `signal.shift(1)` 来生成持仓？
   - 波动率：
     - `vol(t)` 是否只用到了 `ret(<=t)`？
   - 仓位决策：
     - 第 t+1 日仓位是否只由 t 日的信号和波动率决定？

2. **是否有数据泄露？**
   - 波动率阈值：
     - 是否在全样本上先算完所有波动率再「事后」设阈值？
     - 当前实现使用固定阈值，虽然简单，但避免了这类泄露。

3. **手续费与换手是否合理建模？**
   - 是否对趋势策略和波动率调仓策略分别使用了 `position.diff().abs()` 来估算换手？
   - 是否注意到：频繁调仓会放大手续费支出？

4. **参数是否过度调优？**
   - 是否在同一段数据上反复调整 `low_threshold`、`high_threshold` 和仓位倍率，只挑出最好看的组合？
   - 是否有计划在下一阶段做样本外验证？

5. **多曲线对比是否全面？**
   - 在对比 `trend` 与 `trend_vol_adjusted` 时，是否同时看了：
     - 总收益；
     - 最大回撤；
     - 年化波动率；
     - Sharpe；
     - 换手频率（可以通过统计 position 变化次数大致估计）。


### 9. 初步观察与思考方向

在当前 BTC 数据样本上（以默认参数为例），可以重点观察：

- `trend` vs `trend_vol_adjusted`：
  - 回撤是否明显下降？
  - 收益是否保持在一个可接受的水平，还是被过度压缩？
- `trend_vol_adjusted` vs `buy_and_hold`：
  - 在极端波动区间（大涨大跌）中，波动率调仓是否帮助减小了账户波动？

更细一点，可以选几个代表性时间段：

- 明显高波动期：
  - 如大跌或 V 型反转前后的区间，观察波动率调仓是否显著减仓；
- 相对平稳的上升趋势：
  - 看低波动期是否让你充分参与趋势，而不是过度缩仓。


### 10. 小结与下一步

**这一块我已经搞清楚了什么？**

- 波动率不仅是「价格抖动大小」的统计量，更是决定仓位大小的重要参考；
- 可以在保持底层策略逻辑不变的前提下，通过一个独立的波动率模块来调整仓位；
- 在实现上，只要所有统计量都基于「当前及历史数据」，并且持仓始终由前一日信息决定，就能有效规避未来函数；
- 回测时需要同时从收益和风险两侧评价「是否真的更好」，而不是只看收益曲线更光滑。

**还有哪些地方暂时没想透？**

- 如何系统地设定波动阈值，而不是凭经验拍一个 0.01 / 0.03；
- 如何在不太复杂的前提下，让阈值和仓位倍率可以随时间或市场 regime 自适应，而不是一刀切；
- 在多策略/多标的组合下，波动率调仓应该在单策略层面做，还是在组合层面做。

**下一步自然的学习方向：**

1. 在当前框架上做一轮小型参数敏感性测试：
   - 例如尝试不同的 `vol_window` 与阈值组合，对比回撤和 Sharpe 的变化；
2. 将波动率调仓模块叠加到布林带均值回归策略上：
   - 比较「趋势 + 波动率」与「均值回归 + 波动率」的差异；
3. 为后续阶段的「样本外验证与综合复盘」做准备：
   - 在不同年份或不同市场阶段上分别跑一遍上述几种策略，为阶段 2 的综合报告积累材料。
