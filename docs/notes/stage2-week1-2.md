## 阶段 2 第 1 块：趋势跟随原型 + 单标的双均线回测学习笔记

### 0. 本块的学习目标（结果导向）

读完并实践完这一块后，我应该能够独立做到：

- **解释** 趋势跟随策略的基本逻辑，说明它在什么行情赚钱、在什么行情容易被教育。
- **写出** 一套「20 日均线上穿 60 日均线做多，下穿平仓」的完整中文交易规则，补齐建仓/平仓/空仓等细节。
- **翻译** 这套中文规则为伪代码（if/else + 循环结构），并刻意避免未来函数。
- **实现** 一个基于 pandas 的单标的双均线回测：读入 BTC/USDT 日线数据，生成信号、执行交易、输出资金曲线和基础指标。
- **评估与复盘**：能读懂总收益、最大回撤、年化收益、Sharpe 等指标，用交易者视角总结这个策略在哪些区间表现好、在哪些区间被频繁打脸。

### 1. 本学习块在整体计划中的位置

- **在整体路线里的角色**：
  - 阶段 1 主要在打「数据 + 工具 +指标」基础，比如 pandas、滚动窗口、SMA/EMA 等。
  - 阶段 2 开始从「会算指标」升级到「能写出可回测的策略原型」。
  - 第 1 块选用的是最经典的趋势跟随代表 —— 双均线策略，作为从中文规则走向回测代码的第一块跳板。

- **它解决的核心问题**：
  - 把「趋势跟随」这种抽象风格，变成可以精确定义和执行的一套规则。
  - 在一个最小但完整的闭环里，把「读数据 → 生成信号 → 持仓 & 交易 → 资金曲线 & 指标 → 复盘」串起来。

- **为后续内容打下的基础**：
  - 之后的布林带均值回归、波动率调仓模块，都会复用「信号 → 持仓 → 回测 → 评估」这条主线。
  - 本块中整理出的「中文规则 → 伪代码 → 回测实现」套路，可以迁移到任何其他策略上。

### 2. 本块的核心问题 & 直觉图景

学习计划里给出的两个核心问题：

- 趋势跟随是怎么赚钱 / 在什么行情被教育？
- 如何在回测框架里，从「中文规则」变成「可运行策略类/函数」？

我自己的直觉理解：

- **趋势跟随在现实世界里在干什么？**
  - 它不预测顶部和底部，而是等价格已经走出一段「有方向的移动」之后，再顺势上车。
  - 类比：
    - 不是抢在涨停前买，而是等价格已经连续抬高、短期平均线明显站在长期平均线上方，再承认「也许这里确实有一段趋势」，然后跟进去。
  - 赚到的钱，本质上是那些「犹豫观望的人」和「逆势抄底却扛不住的人」贡献的趋势尾部。

- **它什么时候被教育？**
  - 在明显的震荡市间：价格在一个箱体里来回晃，短期均线频繁上下穿越长期均线。
  - 策略会在很多假突破上来回进出，频繁支付手续费和滑点，却拿不到一段顺畅的大趋势。

- **从中文规则到代码的直觉图景**：
  - 人话版本：
    - 「当快线比慢线高，就理解为『市场在上行或至少不弱』，我选择满仓持有；当快线跌到慢线下面，就理解为『趋势可能结束或转弱』，我选择离场观望。」
  - 代码版本：
    - 用一个布尔/0-1 序列代表「明天要不要持仓」，然后让这个序列去乘以明天的收益率，累乘得到资金曲线。

### 3. 关键概念与术语说明

#### 3.1 趋势跟随（Trend Following）

- **直觉解释**：
  - 不管基本面如何，只盯价格行为；价格一路抬高就一路跟，价格跌破关键均线就离场。

- **稍正式一点的描述**：
  - 使用价格的移动平均、突破、通道等指标，构造「价格处于上涨趋势 / 下跌趋势 / 无趋势」的判断规则，据此决定持仓方向和仓位。

- **简单例子**：
  - 如果过去 20 天的平均价一直在抬高，并且明显高于过去 60 天的平均价，可以粗略说「短期趋势比长期更强」，策略选择做多持有。

#### 3.2 双均线、金叉与死叉

- **双均线**：
  - 选定两个不同长度的移动平均：短期（如 20 日）、长期（如 60 日）。
  - 用两条线的相对位置判断趋势。

- **金叉（Golden Cross）**：
  - 短期均线从下向上突破长期均线的时刻。
  - 直觉：短期价格开始明显强于长期平均，是多头力量增强的信号。

- **死叉（Death Cross）**：
  - 短期均线从上向下跌破长期均线的时刻。
  - 直觉：短期价格开始明显弱于长期平均，原有上升趋势可能结束或反转。

#### 3.3 开仓 / 持仓 / 平仓

- **开仓**：从空仓变为持有某个标的，比如从 0 → 1 倍仓位。
- **持仓**：已经有仓位，暂时不做变动。
- **平仓**：把已有仓位全部卖出，从 1 → 0 回到空仓状态。

在本块的简单版本中：

- 只考虑「多头方向」：要么持有 BTC/USDT，要么完全空仓。
- 不做反向做空，也不加杠杆，不分 0.5 仓、0.8 仓等细粒度仓位。

#### 3.4 资金曲线、年化收益、最大回撤、Sharpe

- **资金曲线**：
  - 把初始资金记为 1（或 10,000），每天乘以「1 + 当天策略收益率」，画出来的一条随时间变化的曲线。

- **年化收益率**（粗略版）：
  - 先算出整个回测区间的总收益，再按「一年 N 天」的假设，把这段收益折算成「如果按目前的收益节奏跑满一年，大致会是多少收益率」。

- **最大回撤**：
  - 在资金曲线的历史最高点往后看，资金从峰值跌到之后某个低点的最深跌幅。
  - 直觉：衡量「从你最得意的时刻到被打得最惨的那一刻，账户跌了多少」。

- **Sharpe 比率**（这里用简化版）：
  - 用年化收益率除以年化波动率，粗略度量「单位风险换来的超额收益」。

### 4. 策略画像（任务 1-1）

#### 4.1 赚谁的钱？

- 赚「趋势中坚持不住的人」的钱：
  - 当价格形成一段持续向上的趋势时，很多人会在中途因为短期回撤而提前下车。
  - 趋势策略的逻辑是「不被局部波动吓跑，只要均线结构还在，就死扛趋势」。

- 赚「晚觉悟的人」的钱：
  - 很多人只在趋势已经走了很大一段、社交媒体很热闹的时候才冲进去。
  - 趋势策略通常不会在最高点买入，但会提前布局并相对系统化地退出。

#### 4.2 适合什么行情 / 在什么行情失效？

- **适合的行情**：
  - 明显单边上升或下降的趋势段：比如 BTC 从长期底部一路爬升几倍的牛市，或从高位崩塌的熊市。
  - 趋势越干净（回撤不太多、震荡不剧烈），这类策略越容易吃到中间大段。

- **容易失效的行情**：
  - 箱体震荡、频繁假突破：价格在一个区间内来回，短均线反复上下穿越长均线。
  - 这时策略会频繁交易：
    - 每次看到「刚刚金叉」就进场，结果价格没走远就回落到箱体里；
    - 又在死叉时被迫止损离场，留下很多小亏损和手续费。

#### 4.3 主要风险和可能的大坑

- **过度交易 + 手续费吃掉优势**：
  - 在震荡市里，频繁进出会让手续费和滑点变成主要成本来源。

- **参数过拟合**：
  - 为了让历史回测更好看，不断微调均线长度（比如从 19/59 换到 20/60 再到 21/63），容易变成「专门为这段历史数据量身定做」。

- **未来函数 / 数据泄露**：
  - 如果直接用「当天的信号决定当天的持仓」，就会在逻辑上偷看未来价格（因为信号通常基于当天收盘价）。
  - 必须用「今天的信号 → 决定明天的持仓」的思路，刻意向后错开一天。

- **忽略风险控制**：
  - 只按均线信号进出，不考虑单笔最大亏损、整体回撤、账户层面的风控，会让策略在极端行情下暴露过大风险。

### 5. 中文规则 → 完整描述（任务 1-2）

以计划中的示例规则为基础：

> 20 日均线上穿 60 日均线做多，下穿平仓。

补齐成一套可以直接送进回测框架的中文规则：

1. **标的与周期**：
   - 标的：BTC/USDT 现货（或等价的价格序列）。
   - 周期：日线 K 线，假设每天只有一个收盘价用于决策。

2. **指标定义**：
   - 短期均线 `MA_short(t)`：过去 20 个交易日收盘价的简单算术平均。
   - 长期均线 `MA_long(t)`：过去 60 个交易日收盘价的简单算术平均。

3. **信号定义（当期判断）**：
   - 如果 `MA_short(t) > MA_long(t)`，则记当期信号 `signal_t = 1`（看多）。
   - 否则 `signal_t = 0`（看空 / 不做多）。

4. **实际持仓（避免未来函数）**：
   - 第 `t` 天收盘后，根据当期信号 `signal_t`，决定第 `t+1` 天的持仓：
     - `position_{t+1} = signal_t`。
   - 这样，第 `t+1` 天的收益完全由「前一日收盘前已经确定的决策」决定，不使用未来信息。

5. **交易逻辑**：
   - **建仓（从 0 → 1）**：
     - 当 `position_{t} = 0` 且 `position_{t+1} = 1` 时，在第 `t+1` 天开盘或接近开盘的价位买入，仓位调整到满仓（1 倍）。
   - **持仓（保持 1）**：
     - 当 `position_{t} = 1` 且 `position_{t+1} = 1` 时，继续持有，不做任何交易。
   - **平仓（从 1 → 0）**：
     - 当 `position_{t} = 1` 且 `position_{t+1} = 0` 时，在第 `t+1` 天开盘或接近开盘的价位全部卖出，回到空仓。

6. **仓位与资金管理**：
   - 每次建仓都是用当前全部可用资金买入标的，即「满仓多头」。
   - 不加杠杆，不做分级仓位调整（0.3 仓、0.5 仓等先不考虑）。

7. **手续费与滑点（简化版本）**：
   - 为了简化，在当前实现中：
     - 用一个固定的手续费比例 `fee_rate` 近似表示「每次从 0 → 1 或 1 → 0 的换手成本」。
     - 手续费按「仓位变动量 × fee_rate」来估算，计入当日收益率的扣减项。
   - 滑点暂时不单独建模，未来可以和手续费一起合并成一个更保守的 `fee_rate` 来近似。

### 6. 从中文描述到伪代码（任务 1-2）

下面是对应的伪代码版本，刻意区分「信号」和「持仓」，并向后平移一天以避免未来函数：

```text
输入：
  - 时间序列 t = 1...T
  - 每日收盘价 close[t]
参数：
  - short_window = 20
  - long_window = 60

步骤：
1. 对每个 t 计算短期均线与长期均线：
   ma_short[t] = 过去 short_window 天的 close 平均
   ma_long[t]  = 过去 long_window 天的 close 平均

2. 生成当期信号 signal[t]：
   if ma_short[t] > ma_long[t]:
       signal[t] = 1
   else:
       signal[t] = 0

3. 决定下一天的实际持仓 position[t+1]：
   # 初始化
   position[1] = 0

   对 t 从 1 到 T-1：
       position[t+1] = signal[t]

4. 根据持仓计算策略日收益：
   - 先计算标的日简单收益：
       ret[t] = close[t] / close[t-1] - 1

   - 再计算策略收益（忽略手续费的版本）：
       strategy_ret[t] = position[t-1] * ret[t]

5. 资金曲线：
   equity[0] = 1.0
   对 t 从 1 到 T：
       equity[t] = equity[t-1] * (1 + strategy_ret[t])

输出：
   - ma_short, ma_long, signal, position, strategy_ret, equity
```

每一小步都可以直接映射到 pandas 的列运算上：

- 均线计算 → `rolling().mean()`。
- 信号 → 比较运算+整型转换。
- 持仓 → `signal.shift(1)`。
- 策略收益 → `position * ret`。
- 资金曲线 → `(1 + strategy_ret).cumprod()`。

### 7. 伪代码 → 回测代码（任务 1-3）

在当前仓库中，我用一个最小但清晰分层的实现，把上面的伪代码落地到了 `src/stage2` 目录：

1. **数据加载与预处理：`src/stage2/data/loader.py`**
   - `load_ohlcv_csv(file_path, date_col, price_col, parse_dates)`：
     - 读入 CSV，自动识别日期列与收盘价列，转换为以日期为索引的 DataFrame，并按时间排序。
   - `add_return_columns(df, price_col, log_return)`：
     - 在数据上添加简单日收益率列 `ret`（可选对数收益 `log_ret`）。
   - 这一步对应伪代码中的「输入 close[t]、计算 ret[t]」。

2. **策略层：`src/stage2/strategies/ma_trend.py`**
   - `MATrendConfig`：
     - 用 dataclass 描述策略参数：`short_window`、`long_window`、`price_col`，并在 `validate()` 中检查「窗口为正整数且短期 < 长期」。
   - `MATrendStrategy`：
     - 方法 `generate_signals(df)`：
       - 计算 `ma_short`、`ma_long` 两条均线；
       - 生成 `signal` 列（短期在线上方记为 1，否则 0）；
       - 用 `signal.shift(1)` 得到 `position` 列，避免未来函数；
       - 额外标记 `golden_cross` 和 `death_cross`，方便之后画图或复盘时观察进出场点位。
   - 这一步对应伪代码中的「步骤 1~3：计算均线、生成信号、决定持仓」。

3. **回测脚本：`src/stage2/backtests/bt_ma_trend_single_symbol.py`**
   - `run_ma_trend_backtest(...)`：
     - 加载 CSV → 计算 `ret` → 调用 `MATrendStrategy.generate_signals()` 得到包含 `position` 的 DataFrame。
     - 构造简单持有基准：始终满仓，得到 `bh_ret` 和 `bh_equity`。
     - 构造策略收益：
       - `strategy_ret_gross = position * ret`；
       - 用 `position.diff().abs()` 近似估算每一天的换手率，并按 `fee_rate` 扣减手续费，得到净收益 `strategy_ret`。
     - 计算资金曲线：`bh_equity` 和 `strategy_equity`。
     - 可选画图：若安装了 matplotlib，可绘制两条资金曲线对比图。
   - `compute_performance_stats(returns, trading_days)`：
     - 计算总收益、年化收益、年化波动率、Sharpe、最大回撤等基础指标。
   - `print_stats(stats)`：
     - 以易读的中文格式打印策略与简单持有两套指标。
   - `main()`：
     - 默认使用项目根目录下 `dist/btc_data.csv` 作为数据源，跑一遍双均线回测，并打印尾部几行结果做 sanity check。

整体流程对应学习计划里的「中文规则 → 伪代码 → 回测代码」，并把职责分成了「数据加载 / 策略信号 / 回测与评估」三层，便于后面叠加其他策略或模块。

### 8. 初步评估与小复盘（任务 1-4）

在当前仓库中的回测结果（以现有 `dist/btc_data.csv` 为例，一次实际运行得到的大致数值）：

- **双均线策略（20, 60）**：
  - 总收益约：+1.36%
  - 年化收益约：+1.36%
  - 年化波动率约：27.11%
  - Sharpe 比率约：0.05
  - 最大回撤约：-18%

- **简单持有（买入后一直不动）**：
  - 总收益约：+5.82%
  - 年化收益约：+5.82%
  - 年化波动率约：42.37%
  - Sharpe 比率约：0.14
  - 最大回撤约：-28.10%

从这组数字可以看到几个直观结论：

- 在这段样本区间里，**简单持有的收益更高**，Sharpe 也更好；
- 双均线策略的波动率和最大回撤确实有所下降（风险更小），但收益也被明显削弱；
- 当前参数下，策略更像是「用减少回撤换掉了一部分上涨收益」，在这个样本上并没有打败简单持有。

如果把资金曲线画出来，大致会看到：

- 在比较干净的上涨趋势段（比如价格持续走高、回撤不深的阶段），双均线策略能较好地跟住趋势，资金曲线会较为稳定上行。
- 在明显震荡区间（价格在一个箱体内反复上下），双均线策略的资金曲线会呈现一串「小锯齿」：
  - 每次假突破都导致一次进场和出场；
  - 叠加手续费后，很容易呈现略微下坡或横盘。

从交易者视角看，这个策略像一个：

- **性格有点慢热但能忍住拿住趋势的选手**：
  - 不抢起点，宁可等趋势确认一点再上车；
  - 上车后，只要均线结构还在，就比较能熬得住中途的回撤。
- 同时，它也：
  - **不太擅长在震荡市里自保**：会被来回洗，频繁付出小额亏损和手续费。

### 9. 常见坑与自查清单

在实现和回测这个双均线策略的过程中，我整理了几个需要反复自查的点：

1. **是否存在未来函数？**
   - 检查点：
     - 持仓是否使用了 `signal.shift(1)`？
     - 是否有任何地方用到了「当日收盘价决定当日持仓」？如果是，就要重新设计成「当日收盘价 → 决定下一日持仓」。

2. **手续费是否被忽略或低估？**
   - 检查点：
     - 是否根据 `position.diff().abs()` 来估算换手率？
     - `fee_rate` 是否取了一个相对合理甚至偏保守的值？

3. **参数是否过度为历史数据调优？**
   - 检查点：
     - 是否在同一段历史上试了太多 (short_window, long_window) 组合，只挑表现最好的一组？
     - 是否有计划在下一步做样本外验证，而不是仅仅停留在「这段历史上看起来不错」。

4. **回测指标有没有被误读？**
   - 检查点：
     - 在比较策略与简单持有时，是否同时看了「收益 + 最大回撤 + Sharpe」？
     - 是否注意到「回撤小但收益也更小」可能只是另一种风险收益权衡，而不是「更优」。

5. **代码结构是否便于扩展？**
   - 检查点：
     - 策略逻辑是否被封装在独立的 `MATrendStrategy` 类中？
     - 回测脚本是否只负责组装数据、调用策略、计算收益和指标，而不是把所有逻辑都写在一个大函数里？

### 10. 小结与下一步

**这块内容我已经搞清楚了什么？**

- 能够用自己的话解释「趋势跟随」的赚钱逻辑：
  - 它是用一个相对粗糙但稳健的规则，去吃中间那一大段趋势，而不是赌顶部和底部。
- 能够从零开始写出一套完整的双均线中文交易规则，并补齐开仓/平仓/空仓、手续费等实现细节。
- 能够把这套规则翻译成伪代码，再映射到 pandas 回测实现上：
  - 用滚动均线计算金叉/死叉；
  - 用 `signal` / `position` 区分「决策」和「实际持仓」，避免未来函数；
  - 跑通 BTC/USDT 的单标的回测，并输出基础绩效指标。
- 能大致读懂资金曲线和几个关键指标，知道在当前样本上双均线策略没有战胜简单持有，但在风险（回撤、波动）方面有所改善。

**还有什么暂时没完全想透？**

- 如何系统地选择均线长度（20/60 只是一个经验参数），以及这些参数在不同市场环境下的敏感性。
- 如何在不大幅复杂化策略的前提下，给趋势跟随加上一些简单的「震荡过滤」或「波动率调仓」机制，减少震荡市里的频繁止损。

**下一步的自然学习方向：**

1. **参数敏感性小实验**：
   - 在当前回测框架上，多跑几组 (10, 50)、(30, 90) 等不同双均线组合，对比收益、回撤、Sharpe 的变化，感受策略对参数的敏感程度。

2. **过渡到均值回归与布林带（阶段 2 第 2 块）**：
   - 把当前的「趋势世界观」和即将学习的「均值回归世界观」做对比：
     - 前者是「追着价格跑」，后者是「赌价格会回到一个中心」。
   - 在代码层面，继续沿用「数据加载 → 指标计算 → 信号 → 持仓 → 回测 → 评估」这条主线。

3. **为后续波动率调仓做铺垫（阶段 2 第 3 块）**：
   - 在现有双均线回测框架上，尝试加入一个简单的「高波动减仓、低波动加仓」规则，感受波动率对仓位和回撤的影响，为后面的波动率模块打基础。